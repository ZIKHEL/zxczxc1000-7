<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EasyPython</title>
    <link rel="stylesheet" href="{{ url_for('static', filename= 'css/bootstrap.min.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename= 'css/style.css') }}">
</head>
<body>
    <header class="header">
        <div class="container text-center" >
            <img src="{{ url_for('static', filename= '/img/plogo.png') }}" alt="" width="180px"class="rounded" >
            <h1 class="logo">EasyPython</h1>
            <ul class="nav justify-content-center color-link">
                <li class="nav-item">
                   <a class="nav-link" href="{{ url_for('index') }}">Главная</a>
                <li class="nav-item">
                   <a class="nav-link" href="{{ url_for('lessons') }}">Уроки</a>
                <li class="nav-item">
                   <a class="nav-link" href="{{ url_for('instrument') }}">Инструментарий</a>
                <li class="nav-item">
                   <a class="nav-link" href="{{ url_for('autor') }}">Об авторе</a>
            </ul>
        </div>
    </header>
    <section>
        <div class="container main-text">
            <h2>Урок 8: Функции и рекурсия</h2>
            <h3>1. Функции</h3>
            <p>Напомним, что в математике факториал числа n определяется как n! = 1 ⋅ 2 ⋅ ... ⋅ n. Например, 5! = 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120. Ясно, что факториал можно легко посчитать,
                 воспользовавшись циклом for. Представим, что нам нужно в нашей программе вычислять факториал разных чисел несколько раз (или в разных местах кода). Конечно, можно написать вычисление факториала один раз,
                 а затем используя Copy-Paste вставить его везде, где это будет нужно.</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_1.png') }}" alt="" width="650px">
            <p>Однако, если мы ошибёмся один раз в начальном коде, то потом эта ошибка попадёт в код во все места, куда мы скопировали вычисление факториала. Да и вообще, код занимает больше места, чем мог бы. Чтобы избежать повторного написания одной и той же логики, в языках программирования существуют функции.</p>
            <p><strong>Функции</strong> — это такие участки кода, которые изолированы от остальный программы и выполняются только тогда, когда вызываются. Вы уже встречались с функциями sqrt(), len() и print(). Они все обладают общим свойством: они могут принимать параметры (ноль, один или несколько), и они могут возвращать значение (хотя могут и не возвращать). Например, функция <strong>sqrt()</strong> принимает один параметр и возвращает значение (корень числа). Функция <strong>print() </strong> принимает переменное число параметров и ничего не возвращает.</p>
            <p>Покажем, как написать функцию <strong>factorial()</strong>, которая принимает один параметр — число, и возвращает значение — факториал этого числа.</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_2.png') }}" alt="" width="650px">
            <p>Дадим несколько объяснений. Во-первых, код функции должен размещаться в начале программы, вернее, до того места, где мы захотим воспользоваться функцией factorial(). Первая строчка этого примера является описанием нашей функции. factorial — идентификатор, то есть имя нашей функции. После идентификатора в круглых скобках идет список параметров, которые получает наша функция. Список состоит из перечисленных через запятую идентификаторов параметров. В нашем случае список состоит из одной величины n. В конце строки ставится двоеточие.</p>
            <p>Далее идет тело функции, оформленное в виде блока, то есть с отступом. Внутри функции вычисляется значение факториала числа n и оно сохраняется в переменной res. Функция завершается инструкцией return res, которая завершает работу функции и возвращает значение переменной res.</p>
            <p>Инструкция return может встречаться в произвольном месте функции, ее исполнение завершает работу функции и возвращает указанное значение в место вызова. Если функция не возвращает значения, то инструкция return используется без возвращаемого значения. В функциях, которым не нужно возвращать значения, инструкция return может отсутствовать.</p>
            <p>Приведём ещё один пример. Напишем функцию max(), которая принимает два числа и возвращает максимальное из них (на самом деле, такая функция уже встроена в Питон).</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_3.png') }}" alt="" width="650px">
            <p>Теперь можно написать функцию max3(), которая принимает три числа и возвращает максимальное их них.</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_4.png') }}" alt="" width="650px">
            <p class="border-text">Встроенная функция max() в Питоне может принимать переменное число аргументов и возвращать максимум из них. Приведём пример того, как такая функция может быть написана.</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_5.png') }}" alt="" width="650px">
            <p class="border-text">Все переданные в эту функцию параметры соберутся в один кортеж с именем a, на что указывает звёздочка в строке объявления функции.</p>
            <h3>2. Локальные и глобальные переменные</h3>
            <p>Внутри функции можно использовать переменные, объявленные вне этой функции</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_6.png') }}" alt="" width="650px">
            <p>Здесь переменной a присваивается значение 1, и функция <strong>f()</strong> печатает это значение, несмотря на то, что до объявления функции <strong>f</strong> эта переменная не инициализируется. В момент вызова функции <strong>f()</strong> переменной a уже присвоено значение, поэтому функция <strong>f()</strong> может вывести его на экран.</p>
            <p>Такие переменные (объявленные вне функции, но доступные внутри функции) называются глобальными.</p>
            <p>Но если инициализировать какую-то переменную внутри функции, использовать эту переменную вне функции не удастся. Например:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_7.png') }}" alt="" width="650px">
            <p>Получим ошибку <strong>NameError: name 'a' is not defined</strong>. Такие переменные, объявленные внутри функции, называются локальными. Эти переменные становятся недоступными после выхода из функции.</p>
            <p>Интересным получится результат, если попробовать изменить значение глобальной переменной внутри функции:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_8.png') }}" alt="" width="650px">
            <p>Будут выведены числа 1 и 0. Несмотря на то, что значение переменной a изменилось внутри функции, вне функции оно осталось прежним! Это сделано в целях “защиты” глобальных переменных от случайного изменения из функции. Например, если функция будет вызвана из цикла по переменной <strong>i</strong>, а в этой функции будет использована переменная <strong>i</strong> также для организации цикла, то эти переменные должны быть различными. Если вы не поняли последнее предложение, то посмотрите на следующий код и подумайте, как бы он работал, если бы внутри функции изменялась переменная <strong>i</strong>.</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_9.png') }}" alt="" width="650px">
            <p>Если бы глобальная переменная i изменялась внутри функции, то мы бы получили вот что:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_10.png') }}" alt="" width="650px">
            <p>Итак, если внутри функции модифицируется значение некоторой переменной, то переменная с таким именем становится локальной переменной, и ее модификация не приведет к изменению глобальной переменной с таким же именем.</p>
            <p>Более формально: интерпретатор Питон считает переменную локальной для данной функции, если в её коде есть хотя бы одна инструкция, модифицирующая значение переменной, то эта переменная считается локальной и не может быть использована до инициализации. Инструкция, модифицирующая значение переменной — это операторы <strong> =, +=</strong>, а также использование переменной в качестве параметра цикла <strong>for</strong>. При этом даже если инструкция, модицифицирующая переменную никогда не будет выполнена, интерпретатор это проверить не может, и переменная все равно считается локальной. Пример:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_11.png') }}" alt="" width="650px">
            <p>Возникает ошибка: <strong> local variable 'a' referenced before assignment</strong>. А именно, в функции f() идентификатор a становится локальной переменной, т.к. в функции есть команда, модифицирующая переменную a, пусть даже никогда и не выполняющийся (но интерпретатор не может это отследить). Поэтому вывод переменной a приводит к обращению к неинициализированной локальной переменной.</p>
            <p>Чтобы функция могла изменить значение глобальной переменной, необходимо объявить эту переменную внутри функции, как глобальную, при помощи ключевого слова <strong>global</strong>:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_12.png') }}" alt="" width="650px">
            <p>В этом примере на экран будет выведено 1 1, так как переменная a объявлена, как глобальная, и ее изменение внутри функции приводит к тому, что и вне функции переменная будет доступна.</p>
            <p>Тем не менее, лучше не изменять значения глобальных переменных внутри функции. Если ваша функция должна поменять какую-то переменную, пусть лучше она вернёт это значением, и вы сами при вызове функции явно присвоите в переменную это значение. Если следовать этим правилам, то функции получаются независимыми от кода, и их можно легко копировать из одной программы в другую.</p>
            <p>Например, пусть ваша программа должна посчитать факториал вводимого числа, который вы потом захотите сохранить в переменной f. Вот как это не стоит делать:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_13.png') }}" alt="" width="650px">
            <p>Этот код написан плохо, потому что его трудно использовать ещё один раз. Если вам завтра понадобится в другой программе использовать функцию «факториал», то вы не сможете просто скопировать эту функцию отсюда и вставить в вашу новую программу. Вам придётся поменять то, как она возвращает посчитанное значение.</p>
            <p>Гораздо лучше переписать этот пример так:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_14.png') }}" alt="" width="650px">
            <p>Если нужно, чтобы функция вернула не одно значение, а два или более, то для этого функция может вернуть список из двух или нескольких значений:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_15.png') }}" alt="" width="650px">
            <h3>3. Рекурсия</h3>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_16.png') }}" alt="" width="650px">
            <p>Как мы видели выше, функция может вызывать другую функцию. Но функция также может вызывать и саму себя! Рассмотрим это на примере функции вычисления факториала. Хорошо известно, что 0!=1, 1!=1. А как вычислить величину n! для большого n? Если бы мы могли вычислить величину (n-1)!, то тогда мы легко вычислим n!, поскольку n!=n⋅(n-1)!. Но как вычислить (n-1)!? Если бы мы вычислили (n-2)!, то мы сможем вычисли и (n-1)!=(n-1)⋅(n-2)!. А как вычислить (n-2)!? Если бы... В конце концов, мы дойдем до величины 0!, которая равна 1. Таким образом, для вычисления факториала мы можем использовать значение факториала для меньшего числа. Это можно сделать и в программе на Питоне:</p>
            <img src="{{ url_for('static', filename= '/img/lesson8/les8_17.png') }}" alt="" width="650px">
            <p>Подобный прием (вызов функцией самой себя) называется рекурсией, а сама функция называется рекурсивной.</p>
            <p>Рекурсивные функции являются мощным механизмом в программировании. К сожалению, они не всегда эффективны. Также часто использование рекурсии приводит к ошибкам. Наиболее распространенная из таких ошибок – бесконечная рекурсия, когда цепочка вызовов функций никогда не завершается и продолжается, пока не кончится свободная память в компьютере. Пример бесконечной рекурсии приведен в эпиграфе к этому разделу. Две наиболее распространенные причины для бесконечной рекурсии:</p>
            <ul>
                <li>Неправильное оформление выхода из рекурсии. Например, если мы в программе вычисления факториала забудем поставить проверку if n == 0, то factorial(0) вызовет factorial(-1), тот вызовет factorial(-2) и т. д.</li>
                <li>Рекурсивный вызов с неправильными параметрами. Например, если функция factorial(n) будет вызывать factorial(n), то также получится бесконечная цепочка.</li>
            </ul>
            <p>Поэтому при разработке рекурсивной функции необходимо прежде всего оформлять условия завершения рекурсии и думать, почему рекурсия когда-либо завершит работу.</p>
            <h2>Задача</h2>
            <p>Условие</p>
            <p>Дано действительное положительное число a и целоe число n.</p>
            <p>Вычислите <strong>a</strong> в <strong>n</strong> степени. Решение оформите в виде функции <strong>power(a, n)</strong>.</p>
            <p>Стандартной функцией возведения в степень пользоваться нельзя.</p>
            <p>a = 2</p>
            <p>n = -3</p>
            <iframe height="400px" width="100%" src="https://replit.com/@Director123/AgileSlategreyKeygenerator?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
            <p>Здесь вы можете потренироваться в написании кода:</p>
        </div>
    </section>
    <footer class="header">
        <div class="container">
            <ul class="nav justify-content-center color-text-footer">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('index') }}">Главная</a>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('lessons') }}">Уроки</a>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('instrument') }}">Инструментарий</a>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('autor') }}">Об авторе</a>
            </ul>
            <p class="fotter-text">© 2020-2021. Все права защищены</p>
        </div>
    </footer>
</body>
</html>
